/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.36                          *
*        Compiled Aug 31 2016, 10:53:09                              *
*        (c) 2016 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#include "DIALOG.h"
#include "Emwin_eric800.h"

#include "NumPadDLG.h"
//#include	"GUI.h"
WM_HWIN NM_hWin;

uint8_t SetIndex;
uint8_t NumPadOpen;



static GUI_CONST_STORAGE GUI_COLOR _aColorsArrow[] = { 
	0xFFFFFF, 0x000000 
	};
static GUI_CONST_STORAGE GUI_LOGPALETTE _PalArrow = { 
	2, /* number of entries */ 
	1, /* No transparency */ 
	&_aColorsArrow[0] 
	};
	
 static GUI_CONST_STORAGE unsigned char _acArrowRight[] = { 
________,XX______,________,	 
________,_XXXX___,________, 
________,__XXXXX_,________, 
XXXXXXXX,XXXXXXXX,XX______,
________,__XXXXX_,________, 
________,_XXXX___,________, 
________,XX______,________ 	 
};
static GUI_CONST_STORAGE unsigned char _acArrowLeft[] = {
________,XX______,________,	
_____XXX,X_______,________, 
___XXXXX,________,________, 
XXXXXXXX,XXXXXXXX,XX______, 
___XXXXX,________,________, 
_____XXX,X_______,________, 
________,XX______,________	
 };
static GUI_CONST_STORAGE GUI_BITMAP _bmArrowRight = { 
	18, /* XSize */ 
	7, /* YSize */ 
	3, /* BytesPerLine */ 
	1, /* BitsPerPixel */ 
	_acArrowRight, /* Pointer to picture data (indices) */ 
	&_PalArrow /* Pointer to palette */ 
	};
static GUI_CONST_STORAGE GUI_BITMAP _bmArrowLeft = { 
	18, /* XSize */ 
	7, /* YSize */ 
	3, /* BytesPerLine */ 
	1, /* BitsPerPixel */ 
	_acArrowLeft, /* Pointer to picture data (indices) */ 
	&_PalArrow /* Pointer to palette */ 
	};
//static int _aKey[] = {GUI_KEY_DELETE,GUI_KEY_TAB,GUI_KEY_LEFT,GUI_KEY_RIGHT}; // --------------	(1)	 		
static int _aKey[] = {GUI_KEY_BACKSPACE,GUI_KEY_TAB,GUI_KEY_LEFT,GUI_KEY_RIGHT}; // --------------	(1)	 		
/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_WINDOW_0     (GUI_ID_USER + 0x0)
#define ID_BUTTON_0     (GUI_ID_USER + 0x1)
#define ID_BUTTON_1     (GUI_ID_USER + 0x2)
#define ID_BUTTON_2     (GUI_ID_USER + 0x3)
#define ID_BUTTON_3     (GUI_ID_USER + 0x4)
#define ID_BUTTON_4     (GUI_ID_USER + 0x5)
#define ID_BUTTON_5     (GUI_ID_USER + 0x6)
#define ID_BUTTON_6     (GUI_ID_USER + 0x7)
#define ID_BUTTON_7     (GUI_ID_USER + 0x8)
#define ID_BUTTON_8     (GUI_ID_USER + 0x9)
#define ID_BUTTON_9     (GUI_ID_USER + 0xA)
#define ID_BUTTON_10     (GUI_ID_USER + 0xB)
#define ID_BUTTON_11     (GUI_ID_USER + 0xC)
#define ID_BUTTON_12     (GUI_ID_USER + 0xD)
#define ID_BUTTON_13     (GUI_ID_USER + 0xE)
#define ID_BUTTON_14     (GUI_ID_USER + 0xF)
#define ID_BUTTON_15     (GUI_ID_USER + 0x10)

#define WM_SetValue 		WM_USER + 0x01 /* ????? */ // -------------- (2)

// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreateNumPad[] = {
  { WINDOW_CreateIndirect, "NumPad", ID_WINDOW_0, 550, 110, 200, 340, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_7, 5, 5, 60, 50, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_8, 70, 5, 60, 50, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_9, 135, 5, 60, 50, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_4, 5, 60, 60, 50, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_5, 70, 60, 60, 50, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_6, 135, 60, 60, 50, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_1, 5, 115, 60, 50, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_2, 70, 115, 60, 50, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_3, 135, 115, 60, 50, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_0, 5, 170, 60, 50, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_10, 70, 170, 60, 50, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_11, 135, 170, 60, 50, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_12, 5, 225, 60, 50, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_13, 70, 225, 60, 50, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_14, 135, 225, 60, 50, 0, 0x0, 0 },
	{ BUTTON_CreateIndirect, "Button", ID_BUTTON_15, 60, 280, 80, 50, 0, 0x0, 0 },
	
	
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialogNumPad(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  GUI_RECT r;
  unsigned i;
  int     NCode;
  int     Id;
  int	Pressed;
  WM_HWIN hDlg;
  
  Pressed=0;
  hDlg=pMsg->hWin;
  
  // USER START (Optionally insert additional variables)
  // USER END

  switch (pMsg->MsgId) {
  case WM_PAINT:
  	WM_GetClientRect(&r);
  	GUI_SetColor(0x000000);
  	GUI_DrawRect(r.x0, r.y0, r.x1, r.y1); /* Draw rectangle around it */ /* Draw the bright sides */ 
  	GUI_SetColor(0xffffff); 
  	GUI_DrawHLine(r.y0 + 1,r.x0+1,r.x1 - 2); /* Draw top line */
  	GUI_DrawVLine(r.x0 + 1,r.y0+1,r.y1 - 2); /* Draw the dark sides */ 
  	GUI_SetColor(0x555555); 
  	GUI_DrawHLine(r.y1 -1, r.x0+1,r.x1 - 1); 
  	GUI_DrawVLine(r.x1 -1, r.y0+1,r.y1 - 2); 
  	break;	
  	
  case WM_INIT_DIALOG:
    //
    // Initialization of 'Button'
		NumPadOpen=1;
    GUI_SendKeyMsg(GUI_KEY_TAB, 1);
		GUI_SendKeyMsg(GUI_KEY_BACKTAB, 1);
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_7);
		BUTTON_SetFont(hItem,&GUI_Font32B_ASCII);
    BUTTON_SetText(hItem, "7");
		
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_8);
		BUTTON_SetFont(hItem,&GUI_Font32B_ASCII);
    BUTTON_SetText(hItem, "8");
		
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_9);
		BUTTON_SetFont(hItem,&GUI_Font32B_ASCII);
    BUTTON_SetText(hItem, "9");
		
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_4);
		BUTTON_SetFont(hItem,&GUI_Font32B_ASCII);
    BUTTON_SetText(hItem, "4");
		BUTTON_SetFocussable(hItem, 0);
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_5);
		BUTTON_SetFont(hItem,&GUI_Font32B_ASCII);
    BUTTON_SetText(hItem, "5");
		
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_6);
		BUTTON_SetFont(hItem,&GUI_Font32B_ASCII);
    BUTTON_SetText(hItem, "6");
		
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_1);
		BUTTON_SetFont(hItem,&GUI_Font32B_ASCII);
    BUTTON_SetText(hItem, "1");
		
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_2);
		BUTTON_SetFont(hItem,&GUI_Font32B_ASCII);
    BUTTON_SetText(hItem, "2");
		
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_3);
		BUTTON_SetFont(hItem,&GUI_Font32B_ASCII);
    BUTTON_SetText(hItem, "3");
		
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_0);
		BUTTON_SetFont(hItem,&GUI_Font32B_ASCII);
    BUTTON_SetText(hItem, "0");
		
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_10);
		BUTTON_SetFont(hItem,&GUI_Font32B_ASCII);
    BUTTON_SetText(hItem, ".");
		
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_11);
		BUTTON_SetFont(hItem,&GUI_Font32B_ASCII);
    BUTTON_SetText(hItem, "Del");
		
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_12);
		BUTTON_SetFont(hItem,&GUI_Font32B_ASCII);
    BUTTON_SetText(hItem, "Tab");
		
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_13);
		BUTTON_SetFont(hItem,&GUI_Font20B_ASCII);
    BUTTON_SetText(hItem, "");
		
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_14);
		BUTTON_SetFont(hItem,&GUI_Font20B_ASCII);
    BUTTON_SetText(hItem, "");
		
		
		hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_15);
		BUTTON_SetFont(hItem,&GUI_Font32B_ASCII);
    BUTTON_SetText(hItem, "Enter");
		
		
		
    // USER START (Optionally insert additional code for further widget initialization)
    
    for(i=0;i<GUI_COUNTOF(_aDialogCreateNumPad)-1;i++)
    {
    hItem=WM_GetDialogItem(hDlg,GUI_ID_USER+1+i);
    BUTTON_SetFocussable(hItem,0);/*设置所有的按键不是焦点*/
    switch(i)
    {
    	case 13:
    		BUTTON_SetBitmapEx(hItem, 0, &_bmArrowLeft, 7, 15); /* Set bitmap for arrow left button (unpressed) */
    		BUTTON_SetBitmapEx(hItem, 1, &_bmArrowLeft, 7, 15); /* Set bitmap for arrow left button (pressed) */
    		break;    
    	case 14:
    		BUTTON_SetBitmapEx(hItem, 0, &_bmArrowRight, 7, 15); /* Set bitmap for arrow Right button (unpressed) */
    		BUTTON_SetBitmapEx(hItem, 1, &_bmArrowRight, 7, 15); /* Set bitmap for arrow Right button (pressed) */
    		break;    
    }
    
    }
    
     WM_GetDialogItem(hDlg,GUI_ID_USER+1+12);//?????Why?
     
    // USER END
    break;
	case WM_PRE_PAINT:
		GUI_SendKeyMsg(GUI_KEY_TAB, 1);
		GUI_SendKeyMsg(GUI_KEY_BACKTAB, 1);
		break;
				
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    #if 0
    switch(Id) {
    case ID_BUTTON_0: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_1: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_2: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_3: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_4: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_5: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_6: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_7: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_8: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_9: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_10: // Notifications sent by 'Button'
			
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_11: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_12: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_13: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_14: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
    #endif
    
    switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        Pressed=1;
			//break;
			
      case WM_NOTIFICATION_RELEASED:
				
      	if((Id>=GUI_ID_USER)&&(Id<=(GUI_ID_USER+GUI_COUNTOF(_aDialogCreateNumPad)-1)))
      		{
      			int Key;
      			if(Id<GUI_ID_USER+12)
      				{
      					char acBuffer[10];
      					BUTTON_GetText(pMsg->hWinSrc,acBuffer,sizeof(acBuffer));
      					Key=acBuffer[0];
      				}
      				else if(Id<GUI_ID_USER+16)
      					{
									
      						Key=_aKey[Id-GUI_ID_USER-12];
      					}
	             else
							 {
								 if(Id==GUI_ID_USER+16)
								 {
									 //Enter key
									GUI_EndDialog(pMsg->hWin,0); 
									NumPadOpen=0; 
									switch(SetIndex)
									{		
										case 0:
											WM_SendMessageNoPara(WM_GetClientWindow(TH_hWin), WM_SetValue); //向温湿度设定界面发 WM_SetValue 消息
											break;
										case 1:
											WM_SendMessageNoPara(WM_GetClientWindow(CC_hWin), WM_SetValue); //向通讯设定界面发 WM_SetValue 消息
											break;
										case 2:
											WM_SendMessageNoPara(WM_GetClientWindow(CB_hWin), WM_SetValue); //向柜体设定界面发 WM_SetValue 消息
											break;
										case 3:
											WM_SendMessageNoPara(WM_GetClientWindow(PC_hWin), WM_SetValue); //向PT&CT设定界面发 WM_SetValue 消息
											break;
										case 4:
											WM_SendMessageNoPara(WM_GetClientWindow(LC_hWin), WM_SetValue); //向漏电流设定界面发 WM_SetValue 消息
											break;
										case 5:
											WM_SendMessageNoPara(WM_GetClientWindow(VL_hWin), WM_SetValue); //向电压门限设定界面发 WM_SetValue 消息
											break;
										default:
											break;
									}
									
								 }
								 
								 break;
							 }
      					GUI_SendKeyMsg(Key,Pressed);
      		}
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
    
    
  // USER START (Optionally insert additional message handling)
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateNumPad
*/
WM_HWIN CreateNumPad(void);
WM_HWIN CreateNumPad(void) {
  //WM_HWIN hWin;

  NM_hWin = GUI_CreateDialogBox(_aDialogCreateNumPad, GUI_COUNTOF(_aDialogCreateNumPad), _cbDialogNumPad, WM_HBKWIN, 0, 0);
  return NM_hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
