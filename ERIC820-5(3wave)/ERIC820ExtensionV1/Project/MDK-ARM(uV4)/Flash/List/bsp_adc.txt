; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_adc.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_adc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\User\arithmetic -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX --omf_browse=.\flash\obj\bsp_adc.crf ..\..\User\bsp_stm32f4xx\src\bsp_adc.c]
                          THUMB

                          AREA ||i.ADCInit||, CODE, READONLY, ALIGN=2

                  ADCInit PROC
;;;26     */
;;;27     void ADCInit(void)
000000  b500              PUSH     {lr}
;;;28     {
000002  b09f              SUB      sp,sp,#0x7c
;;;29     	ADC_CommonInitTypeDef ADC_CommonInitStructure;
;;;30         ADC_InitTypeDef       ADC_InitStructure;
;;;31     
;;;32     	DMA_InitTypeDef  DMA_InitStructure;
;;;33     	GPIO_InitTypeDef GPIO_InitStructure;
;;;34     	
;;;35     	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;36     	
;;;37     	
;;;38     	
;;;39     	//GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	
;;;40     	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	
00000c  2000              MOVS     r0,#0
00000e  f88d0017          STRB     r0,[sp,#0x17]
;;;41     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
000012  2003              MOVS     r0,#3
000014  f88d0014          STRB     r0,[sp,#0x14]
;;;42     	GPIO_InitStructure.GPIO_Pin = 	GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2;									
000018  2007              MOVS     r0,#7
00001a  9004              STR      r0,[sp,#0x10]
;;;43     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001c  2002              MOVS     r0,#2
00001e  f88d0015          STRB     r0,[sp,#0x15]
;;;44     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000022  a904              ADD      r1,sp,#0x10
000024  484f              LDR      r0,|L1.356|
000026  f7fffffe          BL       GPIO_Init
;;;45     
;;;46     
;;;47     
;;;48     	
;;;49         
;;;50         //时钟
;;;51         RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE);
00002a  2101              MOVS     r1,#1
00002c  0588              LSLS     r0,r1,#22
00002e  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;52         
;;;53         //DMA设置
;;;54         DMA_InitStructure.DMA_Channel = DMA_Channel_0; //选择通道号
000032  2000              MOVS     r0,#0
000034  9006              STR      r0,[sp,#0x18]
;;;55         DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&(ADC1->DR); //外围设备地址,ADC_DR_DATA规则数据寄存器
000036  484c              LDR      r0,|L1.360|
000038  9007              STR      r0,[sp,#0x1c]
;;;56         DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)(ADCFifo.AD_Value); //DMA存储器地址,自己设置的缓存地址
00003a  484c              LDR      r0,|L1.364|
00003c  9008              STR      r0,[sp,#0x20]
;;;57         DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory; //传输方向,外设->存储器
00003e  2000              MOVS     r0,#0
000040  9009              STR      r0,[sp,#0x24]
;;;58         DMA_InitStructure.DMA_BufferSize = ADCbufSize; //DMA缓存大小,数据传输量32*8
000042  f44f4020          MOV      r0,#0xa000
000046  900a              STR      r0,[sp,#0x28]
;;;59         DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable; //外设是否为增量模式
000048  2000              MOVS     r0,#0
00004a  900b              STR      r0,[sp,#0x2c]
;;;60         DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; //存储器是否为增量模式
00004c  f44f6080          MOV      r0,#0x400
000050  900c              STR      r0,[sp,#0x30]
;;;61         DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord; //外设数据长度半个字(16位)
000052  0040              LSLS     r0,r0,#1
000054  900d              STR      r0,[sp,#0x34]
;;;62         DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord; //存储器数据长度半字(16位)
000056  0080              LSLS     r0,r0,#2
000058  900e              STR      r0,[sp,#0x38]
;;;63         DMA_InitStructure.DMA_Mode = DMA_Mode_Circular; //DMA模式,普通模式、循环模式,还有双缓冲模式,需要特殊设置
00005a  1140              ASRS     r0,r0,#5
00005c  900f              STR      r0,[sp,#0x3c]
;;;64         DMA_InitStructure.DMA_Priority = DMA_Priority_High; //DMA优先级,高优先级
00005e  0240              LSLS     r0,r0,#9
000060  9010              STR      r0,[sp,#0x40]
;;;65         DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable; //不使用FIFO
000062  2000              MOVS     r0,#0
000064  9011              STR      r0,[sp,#0x44]
;;;66         DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull; //FIFO阈值
000066  2001              MOVS     r0,#1
000068  9012              STR      r0,[sp,#0x48]
;;;67         DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single; //存储器突发,单次传输
00006a  2000              MOVS     r0,#0
00006c  9013              STR      r0,[sp,#0x4c]
;;;68         DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single; //外设突发,单次传输
00006e  9014              STR      r0,[sp,#0x50]
;;;69         DMA_Init(DMA2_Stream0, &DMA_InitStructure); //初始化DMA2_Stream0,对应为ADC1
000070  a906              ADD      r1,sp,#0x18
000072  483f              LDR      r0,|L1.368|
000074  f7fffffe          BL       DMA_Init
;;;70     
;;;71         //双缓冲模式设置
;;;72         //DMA_DoubleBufferModeConfig(DMA1_Stream0,(uint32_t)(u16 *)(uAD_Buff_B),DMA_Memory_0);    //DMA_Memory_0首先被传输
;;;73         //DMA_DoubleBufferModeCmd(DMA1_Stream0,ENABLE);
;;;74         
;;;75         //设置DMA中断
;;;76         //DMA_ClearITPendingBit(DMA2_Stream0, DMA_IT_TC); //清除中断标志   
;;;77         //DMA_ITConfig(DMA2_Stream0, DMA_IT_TC, ENABLE); //传输完成中断
;;;78         
;;;79         DMA_Cmd(DMA2_Stream0, ENABLE); //使能DMA
000078  2101              MOVS     r1,#1
00007a  483d              LDR      r0,|L1.368|
00007c  f7fffffe          BL       DMA_Cmd
;;;80     
;;;81     
;;;82     	
;;;83         
;;;84         RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE); //使能ADC1时钟
000080  2101              MOVS     r1,#1
000082  0208              LSLS     r0,r1,#8
000084  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;85         
;;;86         RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1,ENABLE);      //ADC1复位
000088  2101              MOVS     r1,#1
00008a  0208              LSLS     r0,r1,#8
00008c  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;87         RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1,DISABLE); //复位结束     
000090  2100              MOVS     r1,#0
000092  f44f7080          MOV      r0,#0x100
000096  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;88     
;;;89         ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;//独立模式
00009a  2000              MOVS     r0,#0
00009c  901b              STR      r0,[sp,#0x6c]
;;;90         ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles; //两个采样阶段之间的延迟5个时钟(三重模式或双重模式下使用)
00009e  901e              STR      r0,[sp,#0x78]
;;;91         ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled; //DMA失能(对于多个ADC模式)
0000a0  901d              STR      r0,[sp,#0x74]
;;;92         ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div4;//预分频4分频。ADCCLK=PCLK2/4=84/4=21Mhz,ADC时钟最好不要超过36Mhz 
0000a2  f44f3080          MOV      r0,#0x10000
0000a6  901c              STR      r0,[sp,#0x70]
;;;93         ADC_CommonInit(&ADC_CommonInitStructure);//初始化
0000a8  a81b              ADD      r0,sp,#0x6c
0000aa  f7fffffe          BL       ADC_CommonInit
;;;94         
;;;95         ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;//12位模式
0000ae  2000              MOVS     r0,#0
0000b0  9015              STR      r0,[sp,#0x54]
;;;96         ADC_InitStructure.ADC_ScanConvMode = ENABLE;//扫描模式(多通道ADC采集要用扫描模式)    
0000b2  2001              MOVS     r0,#1
0000b4  f88d0058          STRB     r0,[sp,#0x58]
;;;97         ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;//关闭连续转换
0000b8  2000              MOVS     r0,#0
0000ba  f88d0059          STRB     r0,[sp,#0x59]
;;;98     //    ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None; //软件触发
;;;99         ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_Rising; //上升沿触发
0000be  f04f5080          MOV      r0,#0x10000000
0000c2  9017              STR      r0,[sp,#0x5c]
;;;100        //ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T2_TRGO;  //定时器事件2触发ADC
;;;101        //ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T2_CC2;
;;;102    	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T8_TRGO;
0000c4  f04f6060          MOV      r0,#0xe000000
0000c8  9018              STR      r0,[sp,#0x60]
;;;103        ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;//右对齐    
0000ca  2000              MOVS     r0,#0
0000cc  9019              STR      r0,[sp,#0x64]
;;;104        ADC_InitStructure.ADC_NbrOfConversion = ADC_N;    //9个转换在规则序列中
0000ce  2002              MOVS     r0,#2
0000d0  f88d0068          STRB     r0,[sp,#0x68]
;;;105        ADC_Init(ADC1, &ADC_InitStructure);//ADC初始化
0000d4  a915              ADD      r1,sp,#0x54
0000d6  4824              LDR      r0,|L1.360|
0000d8  384c              SUBS     r0,r0,#0x4c
0000da  f7fffffe          BL       ADC_Init
;;;106        
;;;107        //连续模式下,通道的配置
;;;108        ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_15Cycles);  
0000de  2301              MOVS     r3,#1
0000e0  461a              MOV      r2,r3
0000e2  2100              MOVS     r1,#0
0000e4  4820              LDR      r0,|L1.360|
0000e6  384c              SUBS     r0,r0,#0x4c
0000e8  f7fffffe          BL       ADC_RegularChannelConfig
;;;109        ADC_RegularChannelConfig(ADC1, ADC_Channel_2, 2, ADC_SampleTime_15Cycles); 
0000ec  2301              MOVS     r3,#1
0000ee  2202              MOVS     r2,#2
0000f0  4611              MOV      r1,r2
0000f2  481d              LDR      r0,|L1.360|
0000f4  384c              SUBS     r0,r0,#0x4c
0000f6  f7fffffe          BL       ADC_RegularChannelConfig
;;;110        //ADC_RegularChannelConfig(ADC1, ADC_Channel_2, 3, ADC_SampleTime_15Cycles);
;;;111     
;;;112    
;;;113        ADC_DMARequestAfterLastTransferCmd(ADC1, ENABLE); //连续使能DMA
0000fa  2101              MOVS     r1,#1
0000fc  481a              LDR      r0,|L1.360|
0000fe  384c              SUBS     r0,r0,#0x4c
000100  f7fffffe          BL       ADC_DMARequestAfterLastTransferCmd
;;;114        ADC_DMACmd(ADC1, ENABLE);  //使能ADC_DMA
000104  2101              MOVS     r1,#1
000106  4818              LDR      r0,|L1.360|
000108  384c              SUBS     r0,r0,#0x4c
00010a  f7fffffe          BL       ADC_DMACmd
;;;115        ADC_Cmd(ADC1, ENABLE);//开启AD转换器 
00010e  2101              MOVS     r1,#1
000110  4815              LDR      r0,|L1.360|
000112  384c              SUBS     r0,r0,#0x4c
000114  f7fffffe          BL       ADC_Cmd
;;;116    
;;;117    	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;118    	//TIM_OCInitTypeDef TIM_OCInitStructure;
;;;119    	
;;;120    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM8, ENABLE);  
000118  2101              MOVS     r1,#1
00011a  2002              MOVS     r0,#2
00011c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;121    
;;;122    	//定时器设置12.8K
;;;123    	TIM_TimeBaseStructure.TIM_Prescaler = 0; //分频系数,TIM2时钟在分频系数不为1时,时钟是APB1时钟的两倍84M
000120  2000              MOVS     r0,#0
000122  f8ad0004          STRH     r0,[sp,#4]
;;;124    	TIM_TimeBaseStructure.TIM_Period = 13125 - 1; //周期值1M/32=31250,CurrentFreq单位为0.1hz,因此需扩大10倍
000126  f2433044          MOV      r0,#0x3344
00012a  9002              STR      r0,[sp,#8]
;;;125    	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //时钟分频因子
00012c  2000              MOVS     r0,#0
00012e  f8ad000c          STRH     r0,[sp,#0xc]
;;;126    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up ; //向上计数模式
000132  f8ad0006          STRH     r0,[sp,#6]
;;;127    	TIM_TimeBaseInit(TIM8, &TIM_TimeBaseStructure); //初始化定时器2
000136  a901              ADD      r1,sp,#4
000138  480e              LDR      r0,|L1.372|
00013a  f7fffffe          BL       TIM_TimeBaseInit
;;;128    
;;;129    	TIM_ARRPreloadConfig(TIM8, ENABLE); //允许TIM2定时重载
00013e  2101              MOVS     r1,#1
000140  480c              LDR      r0,|L1.372|
000142  f7fffffe          BL       TIM_ARRPreloadConfig
;;;130    	TIM_SelectOutputTrigger(TIM8, TIM_TRGOSource_Update);  //选择TIM2的UPDATA事件更新为触发源
000146  2120              MOVS     r1,#0x20
000148  480a              LDR      r0,|L1.372|
00014a  f7fffffe          BL       TIM_SelectOutputTrigger
;;;131    	TIM_ITConfig(TIM8, TIM_IT_Update, ENABLE); //配置TIM2中断类型
00014e  2201              MOVS     r2,#1
000150  4611              MOV      r1,r2
000152  4808              LDR      r0,|L1.372|
000154  f7fffffe          BL       TIM_ITConfig
;;;132    	
;;;133    	TIM_Cmd(TIM8, ENABLE);
000158  2101              MOVS     r1,#1
00015a  4806              LDR      r0,|L1.372|
00015c  f7fffffe          BL       TIM_Cmd
;;;134    #if 0	
;;;135    	//时钟
;;;136    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);          
;;;137    
;;;138    	//失能定时器
;;;139    	TIM_Cmd(TIM2, DISABLE);
;;;140    	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure); //初始化定时器
;;;141    
;;;142    	//定时器设置6.4K
;;;143    	TIM_TimeBaseStructure.TIM_Prescaler = 0; //分频系数,TIM2时钟在分频系数不为1时,时钟是APB1时钟的两倍84M
;;;144    	TIM_TimeBaseStructure.TIM_Period = 13125 - 1; //周期值1M/32=31250,CurrentFreq单位为0.1hz,因此需扩大10倍
;;;145    	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //时钟分频因子
;;;146    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up ; //向上计数模式
;;;147    	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure); //初始化定时器2
;;;148    
;;;149    
;;;150    	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;//下面详细说明  
;;;151    	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;//TIM_OutputState_Disable;  
;;;152    	TIM_OCInitStructure.TIM_Pulse = 5000;  
;;;153    	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;//如果是PWM1要为Low，PWM2则为High  
;;;154    	TIM_OC2Init(TIM2, & TIM_OCInitStructure);
;;;155    	TIM_InternalClockConfig(TIM2); 
;;;156    	TIM_OC2PreloadConfig(TIM2, TIM_OCPreload_Enable);
;;;157    	TIM_ARRPreloadConfig(TIM2, ENABLE);
;;;158    	
;;;159    	//使能定时器中断    
;;;160    	//TIM_ARRPreloadConfig(TIM2, ENABLE); //允许TIM2定时重载
;;;161    	//TIM_SelectOutputTrigger(TIM2, TIM_TRGOSource_Update);  //选择TIM2的UPDATA事件更新为触发源
;;;162    	//TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE); //配置TIM2中断类型
;;;163    
;;;164    	NVIC_InitTypeDef NVIC_InitStructure;
;;;165    	TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE); //③允许定时器 3 更新中断
;;;166    	NVIC_InitStructure.NVIC_IRQChannel=TIM2_IRQn; //定时器 3 中断
;;;167    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=0x01; //抢占优先级 1
;;;168    	NVIC_InitStructure.NVIC_IRQChannelSubPriority=0x03; //子优先级 3
;;;169    	NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;
;;;170    	NVIC_Init(&NVIC_InitStructure);// ④初始化
;;;171    
;;;172    	//使能TIM2
;;;173    	TIM_Cmd(TIM2, ENABLE); 
;;;174    
;;;175    	//TIM_InternalClockConfig(TIM2);  
;;;176    	//TIM_OC1PreloadConfig(TIM2, TIM_OCPreload_Enable);  
;;;177    	//TIM_UpdateDisableConfig(TIM2, DISABLE);
;;;178    #endif	
;;;179    }//ADCInit
000160  b01f              ADD      sp,sp,#0x7c
000162  bd00              POP      {pc}
;;;180    //ADCInit
                          ENDP

                  |L1.356|
                          DCD      0x40020000
                  |L1.360|
                          DCD      0x4001204c
                  |L1.364|
                          DCD      ADCFifo+0x8
                  |L1.368|
                          DCD      0x40026410
                  |L1.372|
                          DCD      0x40010400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ADCFifo
                          %        81928

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_adc_c_ADCInit____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_bsp_adc_c_ADCInit____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_adc_c_ADCInit____REVSH|
#line 144
|__asm___9_bsp_adc_c_ADCInit____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
