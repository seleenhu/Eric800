; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\mydefine.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\mydefine.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\User\arithmetic -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX --omf_browse=.\flash\obj\mydefine.crf ..\..\User\mydefine.c]
                          THUMB

                          AREA ||i.AsciiToHex||, CODE, READONLY, ALIGN=1

                  AsciiToHex PROC
;;;260    */
;;;261    uint32_t AsciiToHex(uint8_t *Asciibuf,uint8_t Asciibuf_len)
000000  b510              PUSH     {r4,lr}
;;;262    {
000002  4602              MOV      r2,r0
;;;263    	uint32_t data32;
;;;264    	data32 = 0;
000004  2000              MOVS     r0,#0
;;;265    	while(Asciibuf_len--){
000006  e007              B        |L1.24|
                  |L1.8|
;;;266    		data32 = data32*10 + *Asciibuf -'0';
000008  7813              LDRB     r3,[r2,#0]
00000a  eb000480          ADD      r4,r0,r0,LSL #2
00000e  eb030344          ADD      r3,r3,r4,LSL #1
000012  f1a30030          SUB      r0,r3,#0x30
;;;267    		Asciibuf++;
000016  1c52              ADDS     r2,r2,#1
                  |L1.24|
000018  1e0b              SUBS     r3,r1,#0              ;265
00001a  f1a10401          SUB      r4,r1,#1              ;265
00001e  b2e1              UXTB     r1,r4                 ;265
000020  d1f2              BNE      |L1.8|
;;;268    	}
;;;269    	return data32;
;;;270    }//AsciiToHex
000022  bd10              POP      {r4,pc}
;;;271    
                          ENDP


                          AREA ||i.CRC_GetModbus16||, CODE, READONLY, ALIGN=2

                  CRC_GetModbus16 PROC
;;;189    */
;;;190    uint16_t CRC_GetModbus16(uint8_t *pdata, uint16_t len)
000000  b530              PUSH     {r4,r5,lr}
;;;191    {
000002  f5ad7d01          SUB      sp,sp,#0x204
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;192    	//MODBUS CRC-16
;;;193    	const unsigned short g_McRctable_16[256] =
00000a  f44f7200          MOV      r2,#0x200
00000e  4907              LDR      r1,|L2.44|
000010  a801              ADD      r0,sp,#4
000012  f7fffffe          BL       __aeabi_memcpy4
;;;194    	{
;;;195    	0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
;;;196    	0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
;;;197    	0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
;;;198    	0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
;;;199    	0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
;;;200    	0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
;;;201    	0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
;;;202    	0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
;;;203    	0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
;;;204    	0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
;;;205    	0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
;;;206    	0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
;;;207    	0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
;;;208    	0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
;;;209    	0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
;;;210    	0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
;;;211    	0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
;;;212    	0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
;;;213    	0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
;;;214    	0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
;;;215    	0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
;;;216    	0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
;;;217    	0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
;;;218    	0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
;;;219    	0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
;;;220    	0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
;;;221    	0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
;;;222    	0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
;;;223    	0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
;;;224    	0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
;;;225    	0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
;;;226    	0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
;;;227    	};
;;;228    
;;;229      return GetRevCrc_16(pdata, len, 0xFFFF, g_McRctable_16);
000016  ab01              ADD      r3,sp,#4
000018  f64f72ff          MOV      r2,#0xffff
00001c  4629              MOV      r1,r5
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       GetRevCrc_16
;;;230    	//return GetCrc_16(pdata, len, 0xFFFF, g_McRctable_16);
;;;231    }
000024  f50d7d01          ADD      sp,sp,#0x204
000028  bd30              POP      {r4,r5,pc}
;;;232    
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      ||.constdata||

                          AREA ||i.EepromDataInit||, CODE, READONLY, ALIGN=2

                  EepromDataInit PROC
;;;322    */
;;;323    void EepromDataInit(void)
000000  480c              LDR      r0,|L3.52|
;;;324    {
;;;325    	memcpy((uint8_t *)(&EepromData),EEPromBuf,sizeof(EepromStruct));
000002  490d              LDR      r1,|L3.56|
000004  680a              LDR      r2,[r1,#0]  ; EEPromBuf
000006  6002              STR      r2,[r0,#0]  ; EepromData
000008  684a              LDR      r2,[r1,#4]  ; EEPromBuf
00000a  6042              STR      r2,[r0,#4]  ; EepromData
00000c  6889              LDR      r1,[r1,#8]  ; EEPromBuf
00000e  6081              STR      r1,[r0,#8]  ; EepromData
;;;326    	if(EepromPassWord != EepromData.PassWordKey){
000010  8800              LDRH     r0,[r0,#0]  ; EepromData
000012  f24a6102          MOV      r1,#0xa602
000016  4288              CMP      r0,r1
000018  d00a              BEQ      |L3.48|
;;;327    		EepromData.PassWordKey = EepromPassWord;		
00001a  4608              MOV      r0,r1
00001c  4905              LDR      r1,|L3.52|
00001e  8008              STRH     r0,[r1,#0]
;;;328    		EepromData.ratio =  244.93515;
000020  ed9f0a06          VLDR     s0,|L3.60|
000024  4608              MOV      r0,r1
000026  ed800a01          VSTR     s0,[r0,#4]
;;;329    		EepromData.CanID = 0x301;
00002a  f2403001          MOV      r0,#0x301
00002e  8108              STRH     r0,[r1,#8]
                  |L3.48|
;;;330    	}
;;;331    }//EepromDataInit
000030  4770              BX       lr
;;;332    
                          ENDP

000032  0000              DCW      0x0000
                  |L3.52|
                          DCD      EepromData
                  |L3.56|
                          DCD      EEPromBuf
                  |L3.60|
00003c  4374ef66          DCFS     0x4374ef66 ; 244.93515014648438

                          AREA ||i.FIFO_Backpointer||, CODE, READONLY, ALIGN=1

                  FIFO_Backpointer PROC
;;;86     */
;;;87     uint16_t FIFO_Backpointer(uint16_t pointer,uint16_t len,uint16_t sizelen)
000000  4288              CMP      r0,r1
;;;88     {
;;;89     	if(pointer >= len){
000002  db02              BLT      |L4.10|
;;;90     		pointer = pointer - len;
000004  1a43              SUBS     r3,r0,r1
000006  b298              UXTH     r0,r3
000008  e002              B        |L4.16|
                  |L4.10|
;;;91     	}else{
;;;92     		pointer = sizelen - (len-pointer);
00000a  1a0b              SUBS     r3,r1,r0
00000c  1ad3              SUBS     r3,r2,r3
00000e  b298              UXTH     r0,r3
                  |L4.16|
;;;93     	}
;;;94     	return pointer;
;;;95     }//FIFO_Backpointer
000010  4770              BX       lr
;;;96     
                          ENDP


                          AREA ||i.FIFO_bufcmp||, CODE, READONLY, ALIGN=1

                  FIFO_bufcmp PROC
;;;107    */
;;;108    uint8_t FIFO_bufcmp(uint8_t *FIFObuf,uint8_t *buf,uint16_t bt,uint16_t len,uint16_t sizelen)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;109    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  4698              MOV      r8,r3
00000c  f8dd901c          LDR      r9,[sp,#0x1c]
;;;110    	uint16_t i;
;;;111    	i = 0;
000010  2700              MOVS     r7,#0
;;;112    	while(len--){
000012  e00e              B        |L5.50|
                  |L5.20|
;;;113    		if(FIFObuf[bt] != buf[i]){
000014  5d28              LDRB     r0,[r5,r4]
000016  5df1              LDRB     r1,[r6,r7]
000018  4288              CMP      r0,r1
00001a  d002              BEQ      |L5.34|
;;;114    			return 1;
00001c  2001              MOVS     r0,#1
                  |L5.30|
;;;115    		}
;;;116    		i++;
;;;117    		bt = FIFO_pointer(bt,1,sizelen);
;;;118    	}
;;;119    	return 0;
;;;120    }//FIFO_bufcmp
00001e  e8bd83f0          POP      {r4-r9,pc}
                  |L5.34|
000022  1c78              ADDS     r0,r7,#1              ;116
000024  b287              UXTH     r7,r0                 ;116
000026  464a              MOV      r2,r9                 ;117
000028  2101              MOVS     r1,#1                 ;117
00002a  4620              MOV      r0,r4                 ;117
00002c  f7fffffe          BL       FIFO_pointer
000030  4604              MOV      r4,r0                 ;117
                  |L5.50|
000032  f1b80000          SUBS     r0,r8,#0              ;112
000036  f1a80101          SUB      r1,r8,#1              ;112
00003a  fa1ff881          UXTH     r8,r1                 ;112
00003e  d1e9              BNE      |L5.20|
000040  bf00              NOP                            ;119
000042  e7ec              B        |L5.30|
;;;121    #if 0
                          ENDP


                          AREA ||i.FIFO_length||, CODE, READONLY, ALIGN=1

                  FIFO_length PROC
;;;39     */
;;;40     uint16_t FIFO_length(uint16_t bt,uint16_t pt,uint16_t len)
000000  4603              MOV      r3,r0
;;;41     {
;;;42     	if(pt>=bt){
000002  4299              CMP      r1,r3
000004  db02              BLT      |L6.12|
;;;43     		return (pt-bt);
000006  1ac8              SUBS     r0,r1,r3
000008  b280              UXTH     r0,r0
                  |L6.10|
;;;44     	}
;;;45     	return (len-(bt-pt));
;;;46     }//FIFO_length
00000a  4770              BX       lr
                  |L6.12|
00000c  1a58              SUBS     r0,r3,r1              ;45
00000e  1a10              SUBS     r0,r2,r0              ;45
000010  b280              UXTH     r0,r0                 ;45
000012  e7fa              B        |L6.10|
;;;47     /*
                          ENDP


                          AREA ||i.FIFO_pointer||, CODE, READONLY, ALIGN=1

                  FIFO_pointer PROC
;;;56     */
;;;57     uint16_t FIFO_pointer(uint16_t pointer,uint16_t len,uint16_t sizelen)
000000  1843              ADDS     r3,r0,r1
;;;58     {
;;;59     #if 0
;;;60     	while(len--){
;;;61     		pointer++;
;;;62     		if(pointer>=sizelen){
;;;63     			pointer = 0;
;;;64     		}
;;;65     	}
;;;66     #else
;;;67     	if((pointer+len) < sizelen){
000002  4293              CMP      r3,r2
000004  da02              BGE      |L7.12|
;;;68     		pointer += len;
000006  1843              ADDS     r3,r0,r1
000008  b298              UXTH     r0,r3
00000a  e002              B        |L7.18|
                  |L7.12|
;;;69     	}else{
;;;70     		pointer = (pointer+len) - sizelen;
00000c  1843              ADDS     r3,r0,r1
00000e  1a9b              SUBS     r3,r3,r2
000010  b298              UXTH     r0,r3
                  |L7.18|
;;;71     	}
;;;72     #endif
;;;73     	
;;;74     	return pointer;
;;;75     }//FIFO_pointer
000012  4770              BX       lr
;;;76     
                          ENDP


                          AREA ||i.FlashWrite||, CODE, READONLY, ALIGN=2

                  FlashWrite PROC
;;;284    */
;;;285    uint8_t FlashWrite(void)
000000  b570              PUSH     {r4-r6,lr}
;;;286    {
;;;287    	uint8_t *pt;
;;;288    	uint16_t  i;
;;;289    
;;;290    	FLASH_Unlock();
000002  f7fffffe          BL       FLASH_Unlock
;;;291    	FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | 
000006  20f3              MOVS     r0,#0xf3
000008  f7fffffe          BL       FLASH_ClearFlag
;;;292    					FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR|FLASH_FLAG_PGSERR);
;;;293    	
;;;294    	if(FLASH_COMPLETE != FLASH_EraseSector(((uint16_t)0x0018),VoltageRange_3)){
00000c  2102              MOVS     r1,#2
00000e  2018              MOVS     r0,#0x18
000010  f7fffffe          BL       FLASH_EraseSector
000014  2809              CMP      r0,#9
000016  d001              BEQ      |L8.28|
;;;295    		
;;;296    		return 1;
000018  2001              MOVS     r0,#1
                  |L8.26|
;;;297    	}	
;;;298    
;;;299    	pt = (uint8_t *)(&EepromData);
;;;300    	for(i=0;i<sizeof(EepromStruct);i++){		
;;;301    		if(FLASH_COMPLETE != FLASH_ProgramByte(0x0800C000+i,pt[i])){
;;;302    			return 2;
;;;303    		}
;;;304    	}
;;;305    	FLASH_Lock();
;;;306    	
;;;307    	return 0;
;;;308    }//FlashWrite
00001a  bd70              POP      {r4-r6,pc}
                  |L8.28|
00001c  4d09              LDR      r5,|L8.68|
00001e  2400              MOVS     r4,#0                 ;300
000020  e00a              B        |L8.56|
                  |L8.34|
000022  5d29              LDRB     r1,[r5,r4]            ;301
000024  4a08              LDR      r2,|L8.72|
000026  18a0              ADDS     r0,r4,r2              ;301
000028  f7fffffe          BL       FLASH_ProgramByte
00002c  2809              CMP      r0,#9                 ;301
00002e  d001              BEQ      |L8.52|
000030  2002              MOVS     r0,#2                 ;302
000032  e7f2              B        |L8.26|
                  |L8.52|
000034  1c60              ADDS     r0,r4,#1              ;300
000036  b284              UXTH     r4,r0                 ;300
                  |L8.56|
000038  2c0c              CMP      r4,#0xc               ;300
00003a  d3f2              BCC      |L8.34|
00003c  f7fffffe          BL       FLASH_Lock
000040  2000              MOVS     r0,#0                 ;307
000042  e7ea              B        |L8.26|
;;;309    
                          ENDP

                  |L8.68|
                          DCD      EepromData
                  |L8.72|
                          DCD      0x0800c000

                          AREA ||i.GetRevCrc_16||, CODE, READONLY, ALIGN=1

                  GetRevCrc_16 PROC
;;;163    */
;;;164    static uint16_t GetRevCrc_16(uint8_t * pData, uint16_t nLength,uint16_t init, const uint16_t *ptable)
000000  b5f0              PUSH     {r4-r7,lr}
;;;165    {
000002  4604              MOV      r4,r0
;;;166      unsigned short cRc_16 = init;
000004  4610              MOV      r0,r2
;;;167      unsigned char temp;
;;;168    
;;;169      while(nLength-- > 0)
000006  e007              B        |L9.24|
                  |L9.8|
;;;170      {
;;;171        temp = cRc_16 & 0xFF; 
000008  b2c5              UXTB     r5,r0
;;;172        cRc_16 = (cRc_16 >> 8) ^ ptable[(temp ^ *pData++) & 0xFF];
00000a  f8146b01          LDRB     r6,[r4],#1
00000e  406e              EORS     r6,r6,r5
000010  f8336016          LDRH     r6,[r3,r6,LSL #1]
000014  ea862020          EOR      r0,r6,r0,ASR #8
                  |L9.24|
000018  1e0e              SUBS     r6,r1,#0              ;169
00001a  f1a10701          SUB      r7,r1,#1              ;169
00001e  b2b9              UXTH     r1,r7                 ;169
000020  dcf2              BGT      |L9.8|
;;;173      }
;;;174    
;;;175      return cRc_16;
;;;176    }
000022  bdf0              POP      {r4-r7,pc}
;;;177    /*
                          ENDP


                          AREA ||i.TestPinInit||, CODE, READONLY, ALIGN=2

                  TestPinInit PROC
;;;332    
;;;333    void TestPinInit(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;334    {
;;;335    	GPIO_InitTypeDef GPIO_InitStructure;
;;;336    
;;;337    	/* 打开GPIO时钟 */
;;;338    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;339    
;;;340    	/*
;;;341    		配置所有的LED指示灯GPIO为推挽输出模式
;;;342    		由于将GPIO设置为输出时，GPIO输出寄存器的值缺省是0，因此会驱动LED点亮.
;;;343    		这是我不希望的，因此在改变GPIO为输出前，先关闭LED指示灯
;;;344    	*/
;;;345    		
;;;346    
;;;347    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;		/* 设为输出口 */
00000a  2001              MOVS     r0,#1
00000c  f88d0004          STRB     r0,[sp,#4]
;;;348    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
000010  2000              MOVS     r0,#0
000012  f88d0006          STRB     r0,[sp,#6]
;;;349    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 上下拉电阻不使能 */
000016  f88d0007          STRB     r0,[sp,#7]
;;;350    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;	/* IO口最大速度 */
00001a  2003              MOVS     r0,#3
00001c  f88d0005          STRB     r0,[sp,#5]
;;;351    
;;;352    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9|GPIO_Pin_10;
000020  0240              LSLS     r0,r0,#9
000022  9000              STR      r0,[sp,#0]
;;;353    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000024  4669              MOV      r1,sp
000026  4807              LDR      r0,|L10.68|
000028  f7fffffe          BL       GPIO_Init
;;;354    	Test1Clr();
00002c  f44f7100          MOV      r1,#0x200
000030  4804              LDR      r0,|L10.68|
000032  f7fffffe          BL       GPIO_ResetBits
;;;355    	Test2Clr();
000036  f44f6180          MOV      r1,#0x400
00003a  4802              LDR      r0,|L10.68|
00003c  f7fffffe          BL       GPIO_ResetBits
;;;356    	//Test1Set();
;;;357    	//Test2Set();
;;;358    }//TestPinInit
000040  bd1c              POP      {r2-r4,pc}
;;;359    /*----------------------end----------------------------------------------*/
                          ENDP

000042  0000              DCW      0x0000
                  |L10.68|
                          DCD      0x40020000

                          AREA ||.ARM.__AT_0x0800C000||, DATA, READONLY, ALIGN=0

                  EEPromBuf
                          %        16384

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  0000c0c1          DCW      0x0000,0xc0c1
000004  c1810140          DCW      0xc181,0x0140
000008  c30103c0          DCW      0xc301,0x03c0
00000c  0280c241          DCW      0x0280,0xc241
000010  c60106c0          DCW      0xc601,0x06c0
000014  0780c741          DCW      0x0780,0xc741
000018  0500c5c1          DCW      0x0500,0xc5c1
00001c  c4810440          DCW      0xc481,0x0440
000020  cc010cc0          DCW      0xcc01,0x0cc0
000024  0d80cd41          DCW      0x0d80,0xcd41
000028  0f00cfc1          DCW      0x0f00,0xcfc1
00002c  ce810e40          DCW      0xce81,0x0e40
000030  0a00cac1          DCW      0x0a00,0xcac1
000034  cb810b40          DCW      0xcb81,0x0b40
000038  c90109c0          DCW      0xc901,0x09c0
00003c  0880c841          DCW      0x0880,0xc841
000040  d80118c0          DCW      0xd801,0x18c0
000044  1980d941          DCW      0x1980,0xd941
000048  1b00dbc1          DCW      0x1b00,0xdbc1
00004c  da811a40          DCW      0xda81,0x1a40
000050  1e00dec1          DCW      0x1e00,0xdec1
000054  df811f40          DCW      0xdf81,0x1f40
000058  dd011dc0          DCW      0xdd01,0x1dc0
00005c  1c80dc41          DCW      0x1c80,0xdc41
000060  1400d4c1          DCW      0x1400,0xd4c1
000064  d5811540          DCW      0xd581,0x1540
000068  d70117c0          DCW      0xd701,0x17c0
00006c  1680d641          DCW      0x1680,0xd641
000070  d20112c0          DCW      0xd201,0x12c0
000074  1380d341          DCW      0x1380,0xd341
000078  1100d1c1          DCW      0x1100,0xd1c1
00007c  d0811040          DCW      0xd081,0x1040
000080  f00130c0          DCW      0xf001,0x30c0
000084  3180f141          DCW      0x3180,0xf141
000088  3300f3c1          DCW      0x3300,0xf3c1
00008c  f2813240          DCW      0xf281,0x3240
000090  3600f6c1          DCW      0x3600,0xf6c1
000094  f7813740          DCW      0xf781,0x3740
000098  f50135c0          DCW      0xf501,0x35c0
00009c  3480f441          DCW      0x3480,0xf441
0000a0  3c00fcc1          DCW      0x3c00,0xfcc1
0000a4  fd813d40          DCW      0xfd81,0x3d40
0000a8  ff013fc0          DCW      0xff01,0x3fc0
0000ac  3e80fe41          DCW      0x3e80,0xfe41
0000b0  fa013ac0          DCW      0xfa01,0x3ac0
0000b4  3b80fb41          DCW      0x3b80,0xfb41
0000b8  3900f9c1          DCW      0x3900,0xf9c1
0000bc  f8813840          DCW      0xf881,0x3840
0000c0  2800e8c1          DCW      0x2800,0xe8c1
0000c4  e9812940          DCW      0xe981,0x2940
0000c8  eb012bc0          DCW      0xeb01,0x2bc0
0000cc  2a80ea41          DCW      0x2a80,0xea41
0000d0  ee012ec0          DCW      0xee01,0x2ec0
0000d4  2f80ef41          DCW      0x2f80,0xef41
0000d8  2d00edc1          DCW      0x2d00,0xedc1
0000dc  ec812c40          DCW      0xec81,0x2c40
0000e0  e40124c0          DCW      0xe401,0x24c0
0000e4  2580e541          DCW      0x2580,0xe541
0000e8  2700e7c1          DCW      0x2700,0xe7c1
0000ec  e6812640          DCW      0xe681,0x2640
0000f0  2200e2c1          DCW      0x2200,0xe2c1
0000f4  e3812340          DCW      0xe381,0x2340
0000f8  e10121c0          DCW      0xe101,0x21c0
0000fc  2080e041          DCW      0x2080,0xe041
000100  a00160c0          DCW      0xa001,0x60c0
000104  6180a141          DCW      0x6180,0xa141
000108  6300a3c1          DCW      0x6300,0xa3c1
00010c  a2816240          DCW      0xa281,0x6240
000110  6600a6c1          DCW      0x6600,0xa6c1
000114  a7816740          DCW      0xa781,0x6740
000118  a50165c0          DCW      0xa501,0x65c0
00011c  6480a441          DCW      0x6480,0xa441
000120  6c00acc1          DCW      0x6c00,0xacc1
000124  ad816d40          DCW      0xad81,0x6d40
000128  af016fc0          DCW      0xaf01,0x6fc0
00012c  6e80ae41          DCW      0x6e80,0xae41
000130  aa016ac0          DCW      0xaa01,0x6ac0
000134  6b80ab41          DCW      0x6b80,0xab41
000138  6900a9c1          DCW      0x6900,0xa9c1
00013c  a8816840          DCW      0xa881,0x6840
000140  7800b8c1          DCW      0x7800,0xb8c1
000144  b9817940          DCW      0xb981,0x7940
000148  bb017bc0          DCW      0xbb01,0x7bc0
00014c  7a80ba41          DCW      0x7a80,0xba41
000150  be017ec0          DCW      0xbe01,0x7ec0
000154  7f80bf41          DCW      0x7f80,0xbf41
000158  7d00bdc1          DCW      0x7d00,0xbdc1
00015c  bc817c40          DCW      0xbc81,0x7c40
000160  b40174c0          DCW      0xb401,0x74c0
000164  7580b541          DCW      0x7580,0xb541
000168  7700b7c1          DCW      0x7700,0xb7c1
00016c  b6817640          DCW      0xb681,0x7640
000170  7200b2c1          DCW      0x7200,0xb2c1
000174  b3817340          DCW      0xb381,0x7340
000178  b10171c0          DCW      0xb101,0x71c0
00017c  7080b041          DCW      0x7080,0xb041
000180  500090c1          DCW      0x5000,0x90c1
000184  91815140          DCW      0x9181,0x5140
000188  930153c0          DCW      0x9301,0x53c0
00018c  52809241          DCW      0x5280,0x9241
000190  960156c0          DCW      0x9601,0x56c0
000194  57809741          DCW      0x5780,0x9741
000198  550095c1          DCW      0x5500,0x95c1
00019c  94815440          DCW      0x9481,0x5440
0001a0  9c015cc0          DCW      0x9c01,0x5cc0
0001a4  5d809d41          DCW      0x5d80,0x9d41
0001a8  5f009fc1          DCW      0x5f00,0x9fc1
0001ac  9e815e40          DCW      0x9e81,0x5e40
0001b0  5a009ac1          DCW      0x5a00,0x9ac1
0001b4  9b815b40          DCW      0x9b81,0x5b40
0001b8  990159c0          DCW      0x9901,0x59c0
0001bc  58809841          DCW      0x5880,0x9841
0001c0  880148c0          DCW      0x8801,0x48c0
0001c4  49808941          DCW      0x4980,0x8941
0001c8  4b008bc1          DCW      0x4b00,0x8bc1
0001cc  8a814a40          DCW      0x8a81,0x4a40
0001d0  4e008ec1          DCW      0x4e00,0x8ec1
0001d4  8f814f40          DCW      0x8f81,0x4f40
0001d8  8d014dc0          DCW      0x8d01,0x4dc0
0001dc  4c808c41          DCW      0x4c80,0x8c41
0001e0  440084c1          DCW      0x4400,0x84c1
0001e4  85814540          DCW      0x8581,0x4540
0001e8  870147c0          DCW      0x8701,0x47c0
0001ec  46808641          DCW      0x4680,0x8641
0001f0  820142c0          DCW      0x8201,0x42c0
0001f4  43808341          DCW      0x4380,0x8341
0001f8  410081c1          DCW      0x4100,0x81c1
0001fc  80814040          DCW      0x8081,0x4040

                          AREA ||.data||, DATA, ALIGN=2

                  TimData
000000  0000              DCB      0x00,0x00
                  uSCount
000002  0000              DCB      0x00,0x00
                  EepromData
000004  a602              DCW      0xa602
000006  0000              DCB      0x00,0x00
000008  437a123b          DCFS     0x437a123b ; 250.07121276855469
00000c  0000              DCW      0x0000
00000e  0000              DCB      0x00,0x00
                  EepromSaveFlag
000010  00                DCB      0x00
                  FaultbufLen
000011  000000            DCB      0x00,0x00,0x00
                  CanComData
                          DCD      0x10000000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\mydefine.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_mydefine_c_eecfbdd9____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_mydefine_c_eecfbdd9____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_mydefine_c_eecfbdd9____REVSH|
#line 144
|__asm___10_mydefine_c_eecfbdd9____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
